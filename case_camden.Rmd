---
title: "CAL_camden"
output: html_document
date: "2023-06-11"
---

This is a sample borough level CAL calculation in Camden, to reduce the OD pairs being processed to speed up the calculation to test the method.

Issue: Walk/cycle time + parking time can be estimated, but the waiting time has not been figured out yet. 

```{r}
# to increase available memory to java for r5r to 12GB
options(java.parameters = "-Xmx12G")
```

# load packages 

```{r}
library(r5r)
library(sf)
library(data.table)
library(ggplot2)
library(interp)
library(dplyr)
library(tmap)
```

```{r}
#library(devtools)
#devtools::install_github("PublicHealthDataGeek/CycleInfraLnd")
library(CycleInfraLnd)

```

# WP1: access + wait time estimates

### 1. build the network

```{r}
data_path = "C:/Users/99/Documents/CASA/Dissertation_data/input"
list.files(data_path)
```

The data input folder contains: 

1. origin and destination csv files (processed in the data_processing.Rmd)

2. OSM network pbf (downloaded from https://download.geofabrik.de/ on 5 June 2023)

3. London GTFS zip (this data is sourced from https://www.travelinedata.org.uk/traveline-open-data/traveline-national-dataset/ ion 12 June 2023, following the instruction in https://citygeographics.org/r5r-workshop/uk-transit-data-transxchange-and-atoc/)

4. elevation tif (processed in the additional_data_processing.Rmd)

The above files are for r5r travel time estimates. The other files are generated by the setup_r5 function to establish the network data.  

```{r}
# Indicate the path where OSM and GTFS data are stored
r5r_core <- setup_r5(data_path = "C:/Users/99/Documents/CASA/Dissertation_data/input")
```

It takes longer time to get the r5r_core for the first time, and after that r5r will use the cached network.dat in the same directory of data_path to get the network. 

### 2. read in OD points 

After establishing the route networks, the pre-processed origin and destination points should be read in. 

```{r}
origin <- fread(file.path("input/origin.csv"))

destin <- fread(file.path("input/destination.csv"))
```

Since this file is for Camden only,  select the points in Camden by GSS_CODE = E09000007, and then map the points on map to check if they are in the correct. Since it is now data frame with lat lon info, the point data will be converted to sf object for easy mapping. 

```{r}
origin_cam_sf <- origin %>%
  filter(gss_code == "E09000007")%>%
  st_as_sf(.,coords = c("lat", "lon"), crs = 4326)

destin_cam_sf <- destin %>%
  filter(gss_code == "E09000007")%>%
  st_as_sf(.,coords = c("lat", "lon"), crs = 4326)
```

```{r}
destin_cam_sf_ameni <- destin_cam_sf %>%
  filter(amenities == 1)

destin_cam_sf_stati <- destin_cam_sf %>%
  filter(stations == 1)
```

Then get the camden boundary for mapping. 

```{r}
camden <- st_read(here::here("data/London_Boroughs.gpkg"))%>%
  st_transform(., 4326)%>%
  filter(gss_code == "E09000007")
```

Then map 

```{r}
tmap_mode("plot")
t_0 = 
tm_shape(camden) +
  tm_polygons(col = NA, alpha = 0.5) +
tm_shape(origin_cam_sf) +
  tm_dots(col = "blue") +
tm_shape(destin_cam_sf_ameni) +
  tm_dots(col = "red") + 
tm_shape(destin_cam_sf_stati) +
  tm_dots(col = "green")

t_0
```

```{r}
tmap_save(t_0, 'draft_points.png')
```


### 3. routing and travel time prediction

Before calculating the travel time, some parameters are set. 

```{r}
# routing inputs
max_walk_time <- 12 # minutes
max_bike_time <- 12 # minutes
max_trip_duration <- 60 # minutes

# departure datetime (peak time)
departure_datetime = as.POSIXct("24-04-2023 08:00:00", 
                                format = "%d-%m-%Y %H:%M:%S",
                                tz = "GMT")

# departure datetime (off-peak time)
departure_datetime_off = as.POSIXct("23-04-2023 11:00:00", 
                                format = "%d-%m-%Y %H:%M:%S",
                                tz = "GMT")
```

r5r requires the id of points to be in character, not integer.. 

```{r}
origin_cam_sf$id <- origin_cam_sf$id%>%
  as.character(.)

destin_cam_sf$id <- destin_cam_sf$id%>%
  as.character(.)

destin_cam_sf_ameni$id <- destin_cam_sf_ameni$id%>%
  as.character(.)

destin_cam_sf_stati$id <- destin_cam_sf_stati$id%>%
  as.character(.)
```

Estimate the travel time by walking and transit. 

```{r}
# estimate travel time matrix for walk
ttm_walk <- expanded_travel_time_matrix(r5r_core = r5r_core,   
                          origins = origin_cam_sf,
                          destinations = destin_cam_sf,    
                          mode = c("WALK","TRANSIT"),
                          max_walk_time = max_walk_time,
                          max_trip_duration = max_trip_duration,
                          walk_speed = 4.8,
                          bike_speed = 13,
                          departure_datetime = departure_datetime,
                          breakdown = TRUE)

head(ttm_walk, n = 10)
```

For cycle modes, OD pairs with destination as bus stop will be removed.  

```{r}
destin_cam_sf_bike <- destin_cam_sf %>%
  filter(bus_stop == 0)
```

```{r}
# estimate travel time matrix for bike
ttm_bike <- expanded_travel_time_matrix(r5r_core = r5r_core,   
                          origins = origin_cam_sf,
                          destinations = destin_cam_sf_bike,    
                          mode = c("BICYCLE","TRANSIT"),
                          max_bike_time = max_bike_time,
                          max_trip_duration = max_trip_duration,
                          walk_speed = 4.8,
                          bike_speed = 13,
                          departure_datetime = departure_datetime,
                          breakdown = TRUE)

head(ttm_bike, n = 10)
```


### it seems like the GTFS does not suit the data. so only travel time for walk mode is estimated. > how to solve this? 
> option 1: drop waiting time (although this may compromise the comparability with PTAL)
> option 2: drop public transport mode / long distance travel since the focus is on local connectivity
> option 3: sort out how to incorporate GTFS for London correctly. (but this was tried already with different feeds..)

Assuming there is waiting time and GTFS issue is solved - 


```{r}
ttm_walk <-ttm_walk %>%
  rename(walk_time = access_time)%>%
  rename(wait_time_walk = wait_time)%>%
  select("from_id","to_id","walk_time","wait_time_walk","routes")

ttm_bike <-ttm_bike %>%
  rename(bike_time = access_time)%>%
  rename(wait_time_bike = wait_time)%>%
  select("from_id","to_id","bike_time","wait_time_bike","routes")
```

# WP2: parking time estimates

### the popularity of destinations 

Before assessing the parking time, the destinations (PT stations and key amenities) are plotted with the information of how many grids can access that point within set travel time. 

```{r}
bike_destin <- ttm_bike %>%
  group_by(to_id)%>%
  summarise(count=n())
```

```{r}
bike_destin <-bike_destin %>%
  left_join(.,destin_cam_sf,by= join_by("to_id"=="id"))%>%
    st_as_sf(., crs = 4326)
```

Map the demand by the number of possible short trips by bike to destinations. 

```{r}
tmap_mode("plot")

map_demand = 
tm_shape(bike_destin) +
  tm_dots(size="count",col="count",palette="RdYlBu",alpha=0.6)+
tm_shape(camden)+
  tm_polygons(col=NA,alpha=0)

map_demand
```

In this output, due largely to the closed boundary of the borough (rather than considering all the network and points of other boroughs in London) and its long shape limited the journeys within the borough with hot spot in central locations. The actual popular destination in Camden is most likely to be around Kings cross and Euston station to the south of the borough. 

- This demand is not the actual demand since the population density is different in each origin. It represents how many grids can have easy access to the origin. 


### cycle infra availability for parking time weighting

Then, the supply of the parking facilities in the borough will be mapped, as well as how easily can cyclists park their bike from their destinations. 

Since the CID data can be accessed using R package easily, the data will be be pre-processed like OD data points. First, read in parking point data from CID and keep only information necessary. 

```{r}
cid_parking = get_cid_points(type = "cycle_parking")  # select parking point data from the database

cid_parking_cam <-cid_parking%>%
  select("FEATURE_ID","PRK_CPT","BOROUGH","geometry")%>%
  filter(BOROUGH == "Camden")  #Keep only the data within Camden. 
```

To get an overview of the spatial distribution of parking facility in the borough, map the parking facility by the capacity at each spot. 

```{r}
tmap_mode("plot")

map_parking =
tm_shape(cid_parking_cam) +
  tm_dots(size="PRK_CPT",col="PRK_CPT",palette="RdYlBu",alpha=0.6)+
tm_shape(camden)+
  tm_polygons(col=NA,alpha=0)

map_parking
```
The supply of parking space is not even spatially and each spot has different capacity. It seems reasonable that more capacity and higher density of parking spots concentrates around south Camden where the Kings cross and Euston stations are at (with potentially higher demand). 

Popular destinations may receive high demand on parking space that adds time to find the available spot, even if there are close parking spots nearby. On the other hand, destinations far from parking facility may also increase parking time. Since cyclists may move to other parking spots if the nearest one to their destinations are all occupied, the proposed method to measure parking time is as follows: 

The weight to the parking time is positively related to the number of space (capacity) and inversely related to the time taken to travel between destination and parking facility. The more parking facilities in vicinity (more optional facility to go to), the higher the parking weight for the destination. 

## cycle time from destination to parking space 

It is assumed that cyclists will only travel to parking space that can be reached within 5 min. If the parking space is further than this distance, the destination will be regarded as not surrounded by sufficient cycle parking. 

```{r}
# routing inputs
max_bike_time_park <- 5 # minutes
max_trip_duration_park <- 10 # minutes

# departure datetime
# being the same as travel time estimates for OD pairs above, so no need to set again. 
```

```{r}
cid_parking_cam$id <- cid_parking_cam$FEATURE_ID%>%
  as.character(.)
```

Then estimate travel time between destinations (PT stations and key amenities) and parking space. 

```{r}
# estimate travel time matrix for walk
ttm_park <- travel_time_matrix(r5r_core = r5r_core,   
                          origins = destin_cam_sf,
                          destinations = cid_parking_cam,    
                          mode = c("bicycle"),
                          max_bike_time = max_bike_time_park,
                          max_trip_duration = max_trip_duration_park,
                          departure_datetime = departure_datetime)

head(ttm_park, n = 10)
```

## merge cycle time and capacity of parking space 

```{r}
ttm_park <-ttm_park %>%
  left_join(.,cid_parking_cam,by= join_by("to_id"=="id"))%>%
    st_as_sf(., crs = 4326)

```

```{r}
colnames(ttm_park)
```

## calculate the weight 

As mentioned earlier, the capacity of parking spot is also influential to the decision of choosing where to park the bike. The capacity and cycling time are therefore weighted here. 

```{r}
ttm_park<-ttm_park %>%
  select("from_id","to_id","travel_time_p50","PRK_CPT","geometry")%>%
  mutate(to_park_time = case_when(travel_time_p50 == 0 ~ 0.5, 
                                  TRUE ~ travel_time_p50))%>% 
  #travel time set to 0.5 when it is 0, to avoid infinity value when calculating the weight 
  mutate(weight = PRK_CPT/to_park_time)
  
```

## sum all the weights of reachable parking space 

More weight is given to the highest parking space, assuming cyclists choose the one with rationality (high capacity, lower travel time)

```{r}
ttm_park_index <- ttm_park%>%
  group_by(from_id)%>%
  summarise(park_index =0.5*max(weight)+0.5*sum(weight))
```

## map the output 

```{r}
tmap_mode("plot")

map_park_index = 
tm_shape(ttm_park_index) +
  tm_dots(size = 0.15, col = "park_index",palette="RdYlBu") +
tm_shape(camden) +
  tm_polygons(col = NA, alpha = 0)

t4 = tmap_arrange(map_park_index,map_parking,nrow=1)
t4
```
Higher the park index, more easily can cyclists park their bikes. The output makes sense as the left map indicate higher index, easier to park their bikes with higher density and capacity in those locations. However, this again does not consider the local population and actual demand (and demand at different time of day/week). 

```{r}
tmap_save(t4, 'draft_parking_index.png')
```

```{r}
summary(ttm_park_index)
```

# WP3: CAL conversion 

### join bike time with park time estimates

The OD pairs reached by bike can now be attached with the estimated parking time at destination. 

```{r}
ttm_bike_park <- ttm_bike%>%
  left_join(.,ttm_park_index, join_by("to_id"=="from_id"))
```

The parking time is converted from the quantile classification of the parking index. Maximum parking time is set as 5 when the parking index is below the 1st quadrant. 

```{r}
ttm_bike_park<-ttm_bike_park%>%
  mutate(park_time = case_when(park_index < 22.96 ~ 5, 
                               park_index < 42.55 & park_index >= 22.96 ~ 3.5,
                               park_index < 82.76 & park_index >= 42.55 ~ 2,
                                  TRUE ~ 0.5))
```

### combine all the values 

After getting access, wait and park time, combine the datasets for both modes to get access time. Some OD pairs are reachable only through cycling within 12 min, so cycling time will be preserved in this way and others may be accessible via both modes, although cycling is faster walking will be preserved to cater for the accessibility of wider users.

```{r}
ttm_all <- full_join(ttm_walk,ttm_bike_park,by=c("from_id","to_id"))
```

```{r}
ttm_all_test <- ttm_all %>%
  mutate (access_time = case_when (!is.na(walk_time) ~ walk_time + wait_time_walk,
                           !is.na(bike_time) ~ bike_time + wait_time_bike + park_time,
                           TRUE ~ walk_time + wait_time_walk))
```

This is to compare the data with and without parking time estimates and how this influence CAL. 

```{r}
ttm_all_test2 <- ttm_all %>%
  mutate (access_time = case_when (!is.na(walk_time) ~ walk_time + wait_time_walk,
                           !is.na(bike_time) ~ bike_time + wait_time_bike,
                           TRUE ~ walk_time + wait_time_walk))
```

Note: there is no gtfs data imported now, so the waiting time is unknown. 

```{r}
ttm_all_test <- ttm_all_test %>%
  mutate (TAT = case_when (access_time == 0 ~ 0.5,
                           TRUE ~ access_time))
```

```{r}
# this will filter out the OD pairs with TAT over 12 min.. 
# but dont run this
#ttm_all_cap12 <- ttm_all_test %>%
#  filter(TAT <= 12)
```

```{r}
ttm_all_test <- ttm_all_test %>%
  mutate(EDF = 0.5 * (60 / TAT))
```


```{r}
ttm_all_ai <- ttm_all_test %>%
  group_by(from_id)%>%
  summarize(max=max(EDF),sum=sum(EDF),AI=0.5*max(EDF)+0.5*sum(EDF),count=n())
```


```{r}
origin_cam_sf$id<-as.character(origin_cam_sf$id)
# add coordinates of destinations to travel time matrix

ttm_all_ai<-ttm_all_ai%>%
  merge(origin_cam_sf[,c("id","geometry")], by.x = "from_id", by.y = "id")%>%
  st_as_sf(., crs = 4326)

```


```{r}
library(tmap)
 
tmap_mode("plot")
map_AI_w_parking =
  tm_shape(ttm_all_ai) +
  tm_dots(col = "AI",palette="YlOrBr",scale = 3) +
tm_shape(destin_cam_sf_ameni) +
  tm_dots(col = "blue",alpha=0.5)+
tm_shape(camden) +
  tm_polygons(col = NA, alpha = 0)+ 
  tm_layout(title="AI with parking time")

map_AI_w_parking
```

### compare with the one without parking time 

```{r}
ttm_all_test2 <- ttm_all_test2 %>%
  mutate (TAT = case_when (access_time == 0 ~ 0.5,
                           TRUE ~ access_time))%>%
  mutate(EDF = 0.5 * (60 / TAT))
```

```{r}
ttm_all_ai2 <- ttm_all_test2 %>%
  group_by(from_id)%>%
  summarize(max=max(EDF),sum=sum(EDF),AI=0.5*max(EDF)+0.5*sum(EDF),count=n())
```

```{r}
ttm_all_ai2<-ttm_all_ai2%>%
  merge(origin_cam_sf[,c("id","geometry")], by.x = "from_id", by.y = "id")%>%
  st_as_sf(., crs = 4326)

```

```{r}

tmap_mode("plot")
map_AI_wo_parking = 
  tm_shape(ttm_all_ai2) +
  tm_dots(col = "AI",palette="YlOrBr",scale = 3) +
tm_shape(destin_cam_sf_ameni) +
  tm_dots(col = "blue",alpha=0.5)+
tm_shape(camden) +
  tm_polygons(col = NA, alpha = 0)+
  tm_layout(title="AI without parking time")
  

map_AI_wo_parking
```

```{r}
t5 = tmap_arrange(map_AI_w_parking,map_AI_wo_parking,nrow=1)
t5
t6 = tmap_arrange(map_park_index,map_parking,nrow=1)
t6
```

Finally, for cycling mode, destinations with less parking facilities may lead to increased travel time to find and move to the available racks. In northern part of the borough, less cycle parking space is available, hence the overall access index is lower to the north shown on the left map. 

When parking time is not considered in the CAL on the right, the accessibility is more concentric, with high values in central locations as the boundary restricts flow to and from outside the borough. Hence, centre of the borough can reach the key destinations more easily among all the grids. 


```{r}
tmap_save(t5, 'draft_output.png')
```


After processing, remove r5r_core in the environment to avoid taking up memories. 
```{r}
r5r::stop_r5(r5r_core)
rJava::.jgc(R.gc = TRUE)
```
