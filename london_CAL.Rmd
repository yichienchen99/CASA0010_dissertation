---
title: "london_CAL"
output: html_document
date: "2023-07-13"
---

This is the London level CAL calculation (from raw data to travel time estimates to EDF). Since the data folder is too large to upload on GitHub, shared links of the used data are attached accordingly with data source stated in this rmd. 

EDF to CAL conversion and further analysis using the CAL result can be found in the EDF_to_CAL.Rmd. 

```{r}
# to increase available memory to java for r5r to 20GB
options(java.parameters = "-Xmx20G")
```

# load packages 

```{r}
library(r5r)
library(sf)
library(data.table)
#library(interp)
library(dplyr)
library(tmap)
library(grid)
library(stringr)
library(purrr)

#library(devtools)
#devtools::install_github("PublicHealthDataGeek/CycleInfraLnd")
library(CycleInfraLnd)
```

# WP1: access + wait time estimates

## 1. build the network

The data input folder contains: 

1. origin and destination csv files (processed in the data_processing.Rmd)

2. OSM network pbf (downloaded from https://download.geofabrik.de/ on 5 June 2023)

3. London GTFS zip (this data is sourced from https://www.travelinedata.org.uk/traveline-open-data/traveline-national-dataset/ ion 12 June 2023, following the instruction in https://citygeographics.org/r5r-workshop/uk-transit-data-transxchange-and-atoc/)
> this data is not used in the estimation (due to 1- it has missing components after validation, 2- it is also rational that cycle accessibility omits public transport frequency, although reducing the similarity with PTAL method.) 

4. elevation tif (processed in the additional_data_processing.Rmd)

The above files are for r5r travel time estimates. The other files are generated by the setup_r5 function to establish the network data.  

```{r}
# Indicate the path where OSM and GTFS data are stored
r5r_core <- setup_r5(data_path = "C:/Users/99/Documents/CASA/dissertation_test/input")

# or the input directory can be accessed from the shared OneDrive folder here (updated on 1 July, 2023): https://liveuclac-my.sharepoint.com/:f:/g/personal/zcfther_ucl_ac_uk/Em3mws5GdBVJoyMIZv4S4wwBAACSWSiw5kED4jIvOYGzhg?e=qA5jYG
```

It takes longer time to get the r5r_core for the first time, and after that r5r will use the cached network.dat in the same directory of data_path to get the network. 

## 2. read in OD points and geo boundary data

After establishing the route networks, the pre-processed origin and destination points should be read in. 

```{r}
origin_sf <- fread(file.path("input/origin.csv"))%>%
  st_as_sf(.,coords = c("lat", "lon"), crs = 4326)%>%
  select("id","AI2015","PTAL2015","geometry")
```

Since this file is for Camden only,  select the points in Camden by GSS_CODE = E09000007, and then map the points on map to check if they are in the correct. Since it is now data frame with lat lon info, the point data will be converted to sf object for easy mapping. 

Then get the london boundary for mapping. 

```{r}
london <- st_read(here::here("data/London_Boroughs.gpkg"))%>%
  st_transform(., 4326)%>%
  mutate(inner_outer = case_when(ons_inner == "F" ~ "Outer London",
         TRUE ~ "Inner London"))
```
Spatial clipping to ensure all POIs are within the london boundary. 

```{r}
origin_sf <- origin_sf[london,]
```

r5r requires the id of points to be in character, not integer.. 

```{r}
origin_sf$id <- origin_sf$id%>%
  as.character(.)
```


```{r}
towncentres <- st_read(here::here("data/Data_Loubna/Data/centres/CentresPROJECTED.gpkg"))%>%
  select("borough","classification","designation","objectid","planningauthority","sitename")%>%
  st_transform(4326)
```

```{r}
st_centroid_within_poly <- function (poly) {

  # check if centroid is in polygon
  centroid <- poly %>% st_centroid() 
  in_poly <- st_within(centroid, poly, sparse = F)[[1]] 

  # if it is, return that centroid
  if (in_poly) return(centroid) 

  # if not, calculate a point on the surface and return that
  centroid_in_poly <- st_point_on_surface(poly) 
  return(centroid_in_poly)
}

towncentres_cen <- towncentres  %>% 
  mutate(lon = map_dbl(geom, ~st_centroid_within_poly(.x)[[1]]),
         lat = map_dbl(geom, ~st_centroid_within_poly(.x)[[2]]))

towncentres_cen<-towncentres_cen%>%
  st_drop_geometry()

towncentres_cen<-towncentres_cen%>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326)

towncentres_cen <- towncentres_cen%>%
  rename(id = objectid)
towncentres_cen$id <- towncentres_cen$id%>%
  as.character(.)
```

```{r}
tmap_mode("plot")

tm_shape(towncentres) +
  tm_polygons(col=NA, title = "") +
  tm_layout(frame = FALSE, bg.color = NA)+
tm_shape(towncentres_cen) +
  tm_dots(col="red", title = "") +
  tm_layout(frame = FALSE, bg.color = NA)+
  tm_compass(position=c(0,0.1)) + 
  tm_scale_bar(breaks = c(0, 2, 4),position=c(0,0.03)) +
  tm_credits("Data source: OSM", fontface = "italic", position=c(0,0))+
tm_shape(london) +
  tm_polygons(col = NA, alpha = 0, title ="")

```

## 3. routing and travel time prediction

Before calculating the travel time, some parameters are set. Note the departure data depends on the service calendar file in the GTFS zip file. The file (data downloaded using codes in additional_data_processing.rmd) stores the service frequency data from 2023-05-22 to 2023-12-23. 

```{r}
# routing inputs
max_walk_time <- 12 # minutes
max_bike_time <- 12 # minutes
max_trip_duration <- 60 # minutes

# departure datetime (peak time)
departure_datetime = as.POSIXct("26-05-2023 08:00:00", 
                                format = "%d-%m-%Y %H:%M:%S",
                                tz = "GMT")

# departure datetime (off-peak time)
#departure_datetime_off = as.POSIXct("27-05-2023 11:00:00", 
#                                format = "%d-%m-%Y %H:%M:%S",
#                                tz = "GMT")
```



Estimate the travel time by walking. This will be the travel time of all the possible OD pairs from all PTAL grid centroids to all the amenities and stations within 12 min walking distance and 60 min travel time. For walking as the only mode, this can be viewed as the short local trips in the compact city notion. For public transit mode, this can be viewed as the long distance, sustainable, multi-modal trips. For this mode, the access and wait time will be kept as the component of total access time, resembling the sustainable trip within the neighbourhood. 


```{r}
# estimate travel time matrix for walk
ttm_walk_simple <- expanded_travel_time_matrix(r5r_core = r5r_core,   
                          origins = origin_sf,
                          destinations = towncentres_cen,    
                          mode = c("WALK","TRANSIT"),
                          max_walk_time = max_walk_time,
                          max_trip_duration = max_trip_duration,
                          walk_speed = 4.8,
                          bike_speed = 13,
                          departure_datetime = departure_datetime,
                          breakdown = TRUE)

head(ttm_walk_simple, n = 10)
```

```{r}
TAT_walk <- ttm_walk_simple%>%
  mutate(TAT_walk = case_when(!str_detect(`routes`, "WALK") ~ access_time + wait_time,
                    TRUE ~ total_time))

TAT_walk <- TAT_walk%>%
  select("from_id", "to_id","TAT_walk")%>%
  left_join(.,origin_sf,by= join_by("from_id"=="id"))%>%
  st_as_sf(., crs = 4326)%>%
  select("from_id","to_id","TAT_walk","AI2015","PTAL2015","geometry")
```

```{r}
# estimate travel time matrix for bike
ttm_bike_simple <- expanded_travel_time_matrix(r5r_core = r5r_core,   
                          origins = origin_sf,
                          destinations = towncentres_cen,    
                          mode = c("BICYCLE","TRANSIT"),
                          max_bike_time = max_bike_time,
                          max_trip_duration = max_trip_duration,
                          walk_speed = 4.8,
                          bike_speed = 13,
                          departure_datetime = departure_datetime,
                          breakdown = TRUE)

head(ttm_bike_simple, n = 10)
```

```{r}
TAT_bike <- ttm_bike_simple%>%
  mutate(TAT_bike = case_when(!str_detect(`routes`, "BICYCLE") ~ access_time + wait_time,
                    TRUE ~ total_time))

TAT_bike <- TAT_bike%>%
  select("from_id", "to_id","TAT_bike")%>%
  left_join(.,origin_sf,by= join_by("from_id"=="id"))%>%
  st_as_sf(., crs = 4326)%>%
  select("from_id","to_id","TAT_bike","AI2015","PTAL2015","geometry")
```


```{r}
TAT_walk_average<-TAT_walk%>%
  group_by(from_id)%>%
  summarise (average_TAT = mean(TAT_walk))
```

```{r}
tmap_mode("plot")
TAT_by_origin =
  tm_shape(TAT_walk_average) +
  tm_dots(col = "average_TAT",palette="YlOrBr",scale = 3, colorNA = 'white', showNA = FALSE) +
tm_shape(london) +
  tm_polygons(col = NA, alpha = 0)

TAT_by_origin
```


```{r}
TAT_wait_average<-ttm_walk_simple%>%
  group_by(from_id)%>%
  summarise (average_wait = mean(wait_time))%>%
  merge(origin_sf[,c("id","geometry")], by.x = "from_id", by.y = "id")%>%
  st_as_sf(., crs = 4326)

```

```{r}
tmap_mode("plot")
aver_wait_time_by_origin =
  tm_shape(TAT_wait_average) +
  tm_dots(col = "average_wait",palette="YlOrBr",scale = 3, colorNA = 'white', showNA = FALSE) +
tm_shape(london) +
  tm_polygons(col = NA, alpha = 0)

aver_wait_time_by_origin
```

# WP2: parking time estimates

```{r}
cid_parking = get_cid_points(type = "cycle_parking")  # select parking point data from the database

cid_parking <-cid_parking%>%
  select("FEATURE_ID","PRK_CPT","BOROUGH","geometry")
```

```{r}
# routing inputs
max_bike_time_park <- 5 # minutes
max_trip_duration_park <- 10 # minutes

# departure datetime
# being the same as travel time estimates for OD pairs above, so no need to set again. 
```

```{r}
cid_parking$id <- cid_parking$FEATURE_ID%>%
  as.character(.)
```

```{r}
# estimate travel time matrix for walk
ttm_park_simple <- travel_time_matrix(r5r_core = r5r_core,   
                          origins = towncentres_cen,
                          destinations = cid_parking,    
                          mode = c("bicycle"),
                          max_bike_time = max_bike_time_park,
                          max_trip_duration = max_trip_duration_park,
                          departure_datetime = departure_datetime)

head(ttm_park_simple, n = 10)
```

```{r}
ttm_park_simple <-ttm_park_simple %>%
  left_join(.,cid_parking,by= join_by("to_id"=="id"))%>%
    st_as_sf(., crs = 4326)%>%
  st_drop_geometry()

```

```{r}
ttm_park_simple<-ttm_park_simple %>%
  select("from_id","to_id","travel_time_p50","PRK_CPT")%>%
  mutate(to_park_time = case_when(travel_time_p50 == 0 ~ 0.1, 
                                  TRUE ~ travel_time_p50))%>% 
  #travel time set to 0.5 when it is 0, to avoid infinity value when calculating the weight 
  mutate(weight = PRK_CPT/to_park_time)
  
```

```{r}
ttm_park_index <- ttm_park_simple%>%
  group_by(from_id)%>%
  summarise(park_index =0.5*max(weight)+0.5*sum(weight))%>%
  left_join(.,towncentres_cen,by= join_by("from_id"=="id"))%>%
  st_as_sf()%>%
  mutate(park_index = coalesce(park_index, 0))
```

```{r}
tmap_mode("plot")

map_park_index = 
tm_shape(ttm_park_index) +
  tm_dots(size = 0.05, col = "park_index",palette="-RdYlBu", style = "quantile", n=6) +
tm_shape(london) +
  tm_polygons(col = NA, alpha = 0)

map_park_index
```

```{r}
first_quantile = quantile(ttm_park_index$park_index, 0.25)
median = quantile(ttm_park_index$park_index, 0.5)
third_quantile = quantile(ttm_park_index$park_index, 0.75)
```

```{r}
ttm_park_index<-ttm_park_index%>%
  mutate(park_time = case_when(park_index < first_quantile ~ 5, 
                               park_index < median & park_index >= first_quantile ~ 3.5,
                               park_index < third_quantile & park_index >= median ~ 2,
                                  TRUE ~ 0.5))

ttm_park_index_df <- ttm_park_index%>%
   st_drop_geometry()
```

# WP3: CAL conversion 

```{r}
TAT_bike_park <- TAT_bike%>%
  left_join(.,ttm_park_index_df, join_by("to_id"=="from_id"))
```

```{r}
TAT_bike_park_df <- TAT_bike_park%>%
   st_drop_geometry()%>%
  select("from_id", "to_id", "TAT_bike", "park_index", "park_time")

ttm_all <- full_join(TAT_walk,TAT_bike_park_df,by=c("from_id","to_id"))
```

```{r}
#the number of OD pairs that are not reachable by foot or through walk + PT. (can be accessed only by bike)
sum(is.na(ttm_all$TAT_walk))
```

```{r}
#the number of OD pairs that are not reachable by bike or through bike + PT. (can be accessed only by walking)
sum(is.na(ttm_all$TAT_bike))
```

```{r}
ttm_all_test <- ttm_all %>%
  mutate (access_time = case_when (!is.na(TAT_walk) ~ TAT_walk,
                           !is.na(TAT_bike) ~ TAT_bike + park_time,
                           TRUE ~ TAT_walk))
```


```{r}
ttm_all_test <- ttm_all_test %>%
  mutate (TAT = case_when (access_time == 0 ~ 0.1,
                           TRUE ~ access_time))
```

```{r}
ttm_all_test <- ttm_all_test %>%
  mutate(EDF = 0.5 * (60 / TAT))
```

```{r}
colnames(ttm_all_test)
```

```{r}
ttm_all_ai <- ttm_all_test %>%
  select("from_id","EDF", "geometry")
```

# export the data into csv

```{r}
st_write(ttm_all_ai, "london_edf.csv", package="sf")
```

Then the conversion to CAL from EDF is calculated in another file names EDF_to_CAL.Rmd due to the memory span in this file is not enough for the calculation.  

---


---
# Alternative method (more time consuming)

Another option of measuring travel time to key amenities and PT station points individually, which is more intensive. (dont run)

## 2. read in alternative destination point data 

```{r}
destin_sf <- fread(file.path("input/destination.csv"))%>%
  st_as_sf(.,coords = c("lat", "lon"), crs = 4326)%>%
  select("id","bus_stop","amenities","stations","geometry")

destin_sf <- destin_sf[london,]

# convert character in the dataset to boolean values
destin_sf$bus_stop <- destin_sf$bus_stop%>%
  as.logical(.)
destin_sf$amenities <- destin_sf$amenities%>%
  as.logical(.)
destin_sf$stations <- destin_sf$stations%>%
  as.logical(.)

destin_sf$id <- destin_sf$id%>%
  as.character(.)
```

  
```{r}
tmap_mode("plot")

data_point =  
tm_shape(destin_sf) +
  tm_dots(col="red", title = "") +
  tm_layout(frame = FALSE, bg.color = NA)+
  tm_compass(position=c(0,0.1)) + 
  tm_scale_bar(breaks = c(0, 2, 4),position=c(0,0.03)) +
  tm_credits("Data source: OSM", fontface = "italic", position=c(0,0))+
tm_shape(london) +
  tm_polygons(col = NA, alpha = 0, title ="")

data_point
```

## 3. routing and travel time prediction

```{r}
# estimate travel time matrix for walk
ttm_walk <- expanded_travel_time_matrix(r5r_core = r5r_core,   
                          origins = origin_sf,
                          destinations = destin_sf,    
                          mode = c("WALK","TRANSIT"),
                          max_walk_time = max_walk_time,
                          max_trip_duration = max_trip_duration,
                          walk_speed = 4.8,
                          bike_speed = 13,
                          departure_datetime = departure_datetime,
                          breakdown = TRUE)

head(ttm_walk, n = 10)
```


The output contains 1,532,790 rows, indicating the amount of valid OD pairs within set time threshold for travel time. 

Similarly, for cycle modes, OD pairs with destination as bus stop will be removed.  

```{r}
destin_sf_bike <- destin_sf %>%
  filter(bus_stop == 0)
```

```{r}
# estimate travel time matrix for bike
ttm_bike <- expanded_travel_time_matrix(r5r_core = r5r_core,   
                          origins = origin_sf,
                          destinations = destin_sf_bike,    
                          mode = c("BICYCLE","TRANSIT"),
                          max_bike_time = max_bike_time,
                          max_trip_duration = max_trip_duration,
                          walk_speed = 4.8,
                          bike_speed = 13,
                          departure_datetime = departure_datetime,
                          breakdown = TRUE)

head(ttm_bike, n = 10)
```

The output has 565,500 observations. This is largely due to the difference in the number of destinations for bike mode. If the destination remains the same as that for walking, the output logically should have more rows since people may be able to reach further service points within 12 min cycling distance. 

The above two outputs contain the fastest route from origin (PTAL grid centroids) to destinations (amenities and PT stations) by the fastest modes that the routing engine suggested (bike or transit + walk or transit). Instead of selecting among all three modes, the separation between bike and walk can help distinguish and keep the walkable range, as people might not bike for short walkable distance (and not everyone owns a bike so this can reduce the indicator being biased and measure a more holistic travel experience for all). 

The travel time data is now collected/generated. Some data processing is needed to measure the total access time, the sum of access (walk or bike) time and waiting time and parking time. The following section first calculates access and wait time. 

If the mode is purely walking (or cycling), the total time estimated will be the TAT. If the mode is public transit, the access and wait time will be added to give TAT. 

```{r}
TAT_walk <- ttm_walk%>%
  mutate(TAT_walk = case_when(!str_detect(`routes`, "WALK") ~ access_time + wait_time,
                    TRUE ~ total_time))

TAT_bike <- ttm_bike%>%
  mutate(TAT_bike = case_when(!str_detect(`routes`, "BICYCLE") ~ access_time + wait_time,
                    TRUE ~ total_time))
```


```{r}
TAT_walk <- TAT_walk%>%
  select("from_id", "to_id","TAT_walk")%>%
  left_join(.,origin_sf,by= join_by("from_id"=="id"))%>%
  st_as_sf(., crs = 4326)%>%
  select("from_id","to_id","TAT_walk","AI2015","PTAL2015","geometry")

TAT_bike <- TAT_bike%>%
  select("from_id", "to_id","TAT_bike")%>%
  left_join(.,origin_sf,by= join_by("from_id"=="id"))%>%
  st_as_sf(., crs = 4326)%>%
  select("from_id","to_id","TAT_bike","AI2015","PTAL2015","geometry")
```

Plot the mean access time to all reachable destinations for each origin centroid. 

```{r}
TAT_walk_average<-TAT_walk%>%
  group_by(from_id)%>%
  summarise (average_TAT = mean(TAT_walk))
```

```{r}
tmap_mode("plot")
TAT_by_origin =
  tm_shape(TAT_walk_average) +
  tm_dots(col = "average_TAT",palette="YlOrBr",scale = 3, colorNA = 'white', showNA = FALSE) +
tm_shape(destin_sf_stati) +
  tm_dots(col = "blue",alpha=0.5)+
tm_shape(london) +
  tm_polygons(col = NA, alpha = 0)

TAT_by_origin
```
Areas closer to the stations generally obtain lower average time to travel to other destinations. Some origin points can not reach the destinations within the set time threshold, shown as missing values in white.. 

## 4. waiting time mapping (difference between inner and outer London)

merge the average waiting time with the geometry to plot the difference in waiting time when departing from origin. 

```{r}
TAT_wait_average<-ttm_walk%>%
  group_by(from_id)%>%
  summarise (average_wait = mean(wait_time))%>%
  merge(origin_sf[,c("id","geometry")], by.x = "from_id", by.y = "id")%>%
  st_as_sf(., crs = 4326)

```

```{r}
tmap_mode("plot")
aver_wait_time_by_origin =
  tm_shape(TAT_wait_average) +
  tm_dots(col = "average_wait",palette="YlOrBr",scale = 3, colorNA = 'white', showNA = FALSE) +
tm_shape(destin_sf_stati) +
  tm_dots(col = "blue",alpha=0.5)+
tm_shape(london) +
  tm_polygons(col = NA, alpha = 0)

aver_wait_time_by_origin
```
The high waiting time can be seen concentrated at the outer Borough of Camden. This is probably because the PT service has longer time intervals with less options. 

# WP2: parking time estimates

## popularity of destinations 

Before assessing the parking time, the destinations (PT stations and key amenities) are plotted with the information of how many grids can access that point within set travel time. 

```{r}
bike_destin <- ttm_bike %>%
  filter(str_detect(`routes`, "BICYCLE"))%>%
  group_by(to_id)%>%
  summarise(count=n())%>%
  left_join(.,destin_sf,by= join_by("to_id"=="id"))%>%
    st_as_sf(., crs = 4326)
```

Map the demand by the number of possible short trips by bike to destinations. 

```{r}
tmap_mode("plot")

map_demand = 
tm_shape(bike_destin) +
  tm_dots(size=1,col="count",palette="RdYlBu",alpha=0.6)+
tm_shape(london)+
  tm_polygons(col=NA,alpha=0)

map_demand
```

In this output, due largely to the closed boundary of the borough (rather than considering all the network and points of other boroughs in London) and its long shape limited the journeys within the borough with hot spot in central locations. The actual popular destination in Camden is most likely to be around Kings cross and Euston station to the south of the borough. 

- This demand is not the actual demand since the population density is different in each origin. It represents how many grids can have easy access to the origin. 


## cycle infra availability for parking time weighting

Then, the supply of the parking facilities in the borough will be mapped, as well as how easily can cyclists park their bike from their destinations. 

Since the CID data can be accessed using R package easily, the data will be be pre-processed like OD data points. First, read in parking point data from CID and keep only information necessary. 

```{r}
cid_parking = get_cid_points(type = "cycle_parking")  # select parking point data from the database

cid_parking <-cid_parking%>%
  select("FEATURE_ID","PRK_CPT","BOROUGH","geometry")
```

To get an overview of the spatial distribution of parking facility in the borough, map the parking facility by the capacity at each spot. 

```{r}
tmap_mode("plot")

map_parking =
tm_shape(cid_parking) +
  tm_dots(size=0.05,col="PRK_CPT",palette="RdYlBu",style = "jenks", n=6)+
tm_shape(london)+
  tm_polygons(col=NA,alpha=0)

map_parking
```
The supply of parking space is not even spatially and each spot has different capacity. It seems reasonable that more capacity and higher density of parking spots concentrates around south Camden where the Kings cross and Euston stations are at (with potentially higher demand). 

Popular destinations may receive high demand on parking space that adds time to find the available spot, even if there are close parking spots nearby. On the other hand, destinations far from parking facility may also increase parking time. Since cyclists may move to other parking spots if the nearest one to their destinations are all occupied, the proposed method to measure parking time is as follows: 

The weight to the parking time is positively related to the number of space (capacity) and inversely related to the time taken to travel between destination and parking facility. The more parking facilities in vicinity (more optional facility to go to), the higher the parking weight for the destination. 

## cycle time from destination to parking space 

It is assumed that cyclists will only travel to parking space that can be reached within 5 min. If the parking space is further than this distance, the destination will be regarded as not surrounded by sufficient cycle parking. 

```{r}
# routing inputs
max_bike_time_park <- 5 # minutes
max_trip_duration_park <- 10 # minutes

# departure datetime
# being the same as travel time estimates for OD pairs above, so no need to set again. 
```

```{r}
cid_parking$id <- cid_parking$FEATURE_ID%>%
  as.character(.)
```

Then estimate travel time between destinations (PT stations and key amenities) and parking space. 

```{r}
# estimate travel time matrix for walk
ttm_park <- travel_time_matrix(r5r_core = r5r_core,   
                          origins = destin_sf,
                          destinations = cid_parking,    
                          mode = c("bicycle"),
                          max_bike_time = max_bike_time_park,
                          max_trip_duration = max_trip_duration_park,
                          departure_datetime = departure_datetime)

head(ttm_park, n = 10)
```

## merge cycle time and capacity of parking space 

```{r}
ttm_park <-ttm_park %>%
  left_join(.,cid_parking,by= join_by("to_id"=="id"))%>%
    st_as_sf(., crs = 4326)

```

```{r}
colnames(ttm_park)
```

## calculate the weight 

As mentioned earlier, the capacity of parking spot is also influential to the decision of choosing where to park the bike. The capacity and cycling time are therefore weighted here. 

```{r}
ttm_park<-ttm_park %>%
  select("from_id","to_id","travel_time_p50","PRK_CPT","geometry")%>%
  mutate(to_park_time = case_when(travel_time_p50 == 0 ~ 0.1, 
                                  TRUE ~ travel_time_p50))%>% 
  #travel time set to 0.5 when it is 0, to avoid infinity value when calculating the weight 
  mutate(weight = PRK_CPT/to_park_time)
  
```

## sum all the weights of reachable parking space 

More weight is given to the highest parking space, assuming cyclists choose the one with rationality (high capacity, lower travel time)

```{r}
ttm_park_index <- ttm_park%>%
  group_by(from_id)%>%
  summarise(park_index =0.5*max(weight)+0.5*sum(weight))
```

## map the output 

```{r}
tmap_mode("plot")

map_park_index = 
tm_shape(ttm_park_index) +
  tm_dots(size = 0.05, col = "park_index",palette="-RdYlBu", style = "quantile", n=6) +
tm_shape(london) +
  tm_polygons(col = NA, alpha = 0)

t4 = tmap_arrange(map_park_index,map_parking,nrow=1)
t4
```
Higher the park index, more easily can cyclists park their bikes. The output makes sense as the left map indicate higher index, easier to park their bikes with higher density and capacity in those locations. However, this again does not consider the local population and actual demand (and demand at different time of day/week). 

```{r}
tmap_save(t4, 'draft_parking_index.png')
```

```{r}
summary(ttm_park_index)
```

# WP3: CAL conversion 

## join bike time with park time estimates

The OD pairs reached by bike can now be attached with the estimated parking time at destination. 

```{r}
first_quantile = quantile(ttm_park_index$park_index, 0.25)
median = quantile(ttm_park_index$park_index, 0.5)
third_quantile = quantile(ttm_park_index$park_index, 0.75)
```

```{r}
ttm_park_index<-ttm_park_index%>%
  mutate(park_time = case_when(park_index < first_quantile ~ 5, 
                               park_index < median & park_index >= first_quantile ~ 3.5,
                               park_index < third_quantile & park_index >= median ~ 2,
                                  TRUE ~ 0.5))

ttm_park_index_df <- ttm_park_index%>%
   st_drop_geometry()

TAT_bike_park <- TAT_bike%>%
  left_join(.,ttm_park_index_df, join_by("to_id"=="from_id"))
```

The parking time is converted from the quantile classification of the parking index. Maximum parking time is set as 5 when the parking index is below the 1st quadrant. 


## combine all the values 

After getting access, wait and park time, combine the datasets for both modes to get access time. Some OD pairs are reachable only through cycling within 12 min, so cycling time will be preserved in this way and others may be accessible via both modes, although cycling is faster walking will be preserved to cater for the accessibility of wider users.

```{r}
TAT_bike_park_df <- TAT_bike_park%>%
   st_drop_geometry()%>%
  select("from_id", "to_id", "TAT_bike", "park_index", "park_time")

ttm_all <- full_join(TAT_walk,TAT_bike_park_df,by=c("from_id","to_id"))
```

```{r}
#the number of OD pairs that are not reachable by foot or through walk + PT. (can be accessed only by bike)
sum(is.na(ttm_all$TAT_walk))
```


```{r}
#the number of OD pairs that are not reachable by bike or through bike + PT. (can be accessed only by walking)
sum(is.na(ttm_all$TAT_bike))

```


## select the mode for CAL 

For OD pairs reachable by walking within the walkable range, walking time will be used since walking is a more inclusive mode that the majority of people can take compared to cycling that may require more physical effort and some investment in bikes and accessories. (when walk time != NA => use walk time)
Beyond the walkable distance, cycling mode will be used. (when walk time = NA => use bike time)
However, it is also possible that within walking distance, the bike can not access roads.. so there may be NA values for bike time when the walk time is within the threshold. (when bike time = NA => use walk time)

```{r}
ttm_all_test <- ttm_all %>%
  mutate (access_time = case_when (!is.na(TAT_walk) ~ TAT_walk,
                           !is.na(TAT_bike) ~ TAT_bike + park_time,
                           TRUE ~ TAT_walk))
```

This is to compare the data with and without parking time estimates and how this influence CAL. 

```{r}
ttm_all_test2 <- ttm_all %>%
  mutate (access_time = case_when (!is.na(TAT_walk) ~ TAT_walk,
                           !is.na(TAT_bike) ~ TAT_bike,
                           TRUE ~ TAT_walk))
```

Note: there is no gtfs data imported now, so the waiting time is unknown. 

```{r}
ttm_all_test <- ttm_all_test %>%
  mutate (TAT = case_when (access_time == 0 ~ 0.1,
                           TRUE ~ access_time))
```

```{r}
# this will filter out the OD pairs with TAT over 12 min.. 
# but dont run this
#ttm_all_cap12 <- ttm_all_test %>%
#  filter(TAT <= 12)
```

```{r}
ttm_all_test <- ttm_all_test %>%
  mutate(EDF = 0.5 * (60 / TAT))
```


```{r}
ttm_all_ai <- ttm_all_test %>%
  group_by(from_id)%>%
  summarize(max=max(EDF),sum=sum(EDF),AI=0.5*max(EDF)+0.5*sum(EDF),count=n())
```


```{r}
#origin_cam_sf$id<-as.character(origin_cam_sf$id)
# add coordinates of destinations to travel time matrix

#ttm_all_ai<-ttm_all_ai%>%
#  merge(origin_cam_sf[,c("id","geometry")], by.x = "from_id", by.y = "id")%>%
#  st_as_sf(., crs = 4326)

```

```{r}
destin_sf_ameni <- destin_sf %>%
  filter(amenities == 1)

destin_sf_stati <- destin_sf %>%
  filter(stations == 1)

destin_sf_ameni$id <- destin_sf_ameni$id%>%
  as.character(.)

destin_sf_stati$id <- destin_sf_stati$id%>%
  as.character(.)
```


```{r}
library(tmap)
 
tmap_mode("plot")
map_AI_w_parking =
  tm_shape(ttm_all_ai) +
  tm_dots(col = "AI",palette="-viridis",
          n = 6,
          style = "equal",
          scale = 3, 
          showNA = FALSE,
          colorNA = 'white',
          legend.hist = TRUE,
          title = "Access Index",) +
tm_shape(destin_sf_ameni) +
  tm_dots(col = "blue",
          alpha=0.5)+
tm_shape(london) +
  tm_polygons(col = NA, 
              alpha = 0)+ 
  tm_layout(title="AI with parking time",
             frame = FALSE,
             legend.outside = TRUE,
             legend.text.size = 1,
             legend.hist.size = 1,
             legend.hist.width = 0.75)


map_AI_w_parking
```
The distribution of AI is quite similar to that of average travel time by walking mapped earlier. With areas around the stations and amenities being more accessible, scoring higher in AI. Areas to the north have lower score with lower density in destinations and PT services. 

## compare with the one without parking time 

```{r}
ttm_all_test2 <- ttm_all_test2 %>%
  mutate (TAT = case_when (access_time == 0 ~ 0.1,
                           TRUE ~ access_time))%>%
  mutate(EDF = 0.5 * (60 / TAT))
```

```{r}
ttm_all_ai2 <- ttm_all_test2 %>%
  group_by(from_id)%>%
  summarize(max=max(EDF),sum=sum(EDF),AI=0.5*max(EDF)+0.5*sum(EDF),count=n())
```

```{r}
#ttm_all_ai2<-ttm_all_ai2%>%
#  merge(origin_cam_sf[,c("id","geometry")], by.x = "from_id", by.y = "id")%>%
#  st_as_sf(., crs = 4326)

```

```{r}

tmap_mode("plot")
map_AI_wo_parking = 
  tm_shape(ttm_all_ai2) +
  tm_dots(col = "AI",
          palette="-viridis",
          n = 6,
          style = "equal",
          scale = 3, 
          showNA = FALSE,
          colorNA = 'white',
          legend.hist = TRUE,
          title = "Access Index",) +
tm_shape(destin_sf_ameni) +
  tm_dots(col = "blue",
          alpha=0.5)+
tm_shape(london) +
  tm_polygons(col = NA, 
              alpha = 0)+
  tm_layout(title="AI without parking time",
             frame = FALSE,
             legend.outside = TRUE,
             legend.text.size = 1,
             legend.hist.size = 1,
             legend.hist.width = 0.75)
  

map_AI_wo_parking
```
```{r}
#this chunk is just to compare the difference between the ones with and without parking time taking into account. 
#map_AI_w_parking
#map_AI_wo_parking
```

```{r}
# AB map with and without parking time in access index 
t5 = tmap_arrange(map_AI_w_parking,map_AI_wo_parking,nrow=1)
t5
# estimated parking index and parking capacity location 
t6 = tmap_arrange(map_park_index,map_parking,nrow=1)
t6
```

Finally, for cycling mode, destinations with less parking facilities may lead to increased travel time to find and move to the available racks. In northern part of the borough, less cycle parking space is available, hence the overall access index is lower to the north shown on the left map. 

When parking time is not considered in the CAL on the right, the accessibility is more concentric, with high values in central locations as the boundary restricts flow to and from outside the borough. Hence, centre of the borough can reach the key destinations more easily among all the grids. 


```{r}
tmap_save(t5, 'draft_output.png')
```



After processing, remove r5r_core in the environment to avoid taking up memories. 
```{r}
r5r::stop_r5(r5r_core)
rJava::.jgc(R.gc = TRUE)
```