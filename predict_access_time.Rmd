---
title: "predict_access_time"
output: html_document
date: "2023-05-31"
---

## Access time prediction 

Since there are too many OD pairs to run for London, this section first test-runs the codes using one borough's OD pairs (Camden). It then goes into the travel time estimation for London. 

```{r}
# to increase available memory to java for r5r to 5GB
options(java.parameters = "-Xmx12G")
```

```{r}
library(r5r)
library(sf)
library(data.table)
library(ggplot2)
library(interp)
library(dplyr)
library(tmap)

```

### 1. Build routable transport network

```{r}
data_path = "C:/Users/99/Documents/CASA/Dissertation_data/input"
list.files(data_path)
```

```{r}
# Indicate the path where OSM and GTFS data are stored
r5r_core <- setup_r5(data_path = "C:/Users/99/Documents/CASA/Dissertation_data/input")

```

Plot the network to check. The layout seems ok. But it takes a while to run. 

```{r}
# extract OSM network
#street_net <- street_network_to_sf(r5r_core)


# plot
#ggplot() +
#  geom_sf(data = street_net$edges, color='gray85') +
#  theme_void()
```


Since the accessibility and travel time metrics return empty outcomes. A couple of sources of error are being investigated, including adding some optional file to the r5rdata folder that creates r5r_core for network construction (see additional_data_processing.RMD). 


### 2. read in OD points 

```{r}
origin <- fread(file.path("input/origin.csv"))

destin <- fread(file.path("input/destination.csv"))
head(destin)
               
```

select the points in Camden / GSS_CODE = E09000007. 

```{r}
origin_cam <- origin %>%
  filter(gss_code == "E09000007")

destin_cam <- destin %>%
  filter(gss_code == "E09000007")
```



then try to map the points on map to check if they are in the right place. 

since it is now data frame with lat lon info, the point data will be converted to sf object. 

```{r}
origin_cam_sf <- origin_cam %>%
  st_as_sf(.,coords = c("lat", "lon"), crs = 4326)

destin_cam_sf <- destin_cam %>%
  st_as_sf(.,coords = c("lat", "lon"), crs = 4326)
```


Then get the london boundary for mapping. 

```{r}
London_borough <- st_read(here::here("data/London_Boroughs.gpkg"))%>%
    st_transform(., 4326)
```

```{r}
camden <- London_borough%>%
  filter(gss_code == "E09000007")
```

Then map 

```{r}
tmap_mode("plot")
tm_shape(camden) +
  tm_polygons(col = NA, alpha = 0.5) +
tm_shape(origin_cam_sf) +
  tm_dots(col = "blue") +
tm_shape(destin_cam_sf) +
  tm_dots(col = "red")
```

Good! the points seem within boundary. when running travel time estimate below, it is found that after making the data frame containing id, lat, lon columns to sf objects, the problem of getting empty output is resolved! (6 June)

Then map to check OD locations for London. It'll be great to see the spatial distribution of stations and key amenities separately. 


```{r}
origin_sf <- origin %>%
  st_as_sf(.,coords = c("lat", "lon"), crs = 4326)

destin_sf <- destin %>%
  st_as_sf(.,coords = c("lat", "lon"), crs = 4326)
```

```{r}
destin_sf_ameni <- destin_sf%>% 
  filter(amenities==1)

destin_sf_station <- destin_sf%>% 
  filter(stations==1)
```

Map the key amenities identified. 

```{r}
tmap_mode("plot")
tm_shape(London_borough) +
  tm_polygons(col = NA, alpha = 0.5) +
tm_shape(origin_sf) +
  tm_dots(col = "blue") +
tm_shape(destin_sf_ameni) +
  tm_dots(col = "red")
```

Then map the public transit stations. 

```{r}
tmap_mode("plot")
tm_shape(London_borough) +
  tm_polygons(col = NA, alpha = 0.5) +
tm_shape(origin_sf) +
  tm_dots(col = "blue") +
tm_shape(destin_sf_station) +
  tm_dots(col = "red")
```

### 3. Routing analysis 

## a. Fast many to many travel time matrix

calculate all-to-all travel time estimates within a 60-minute time window departing between 8am and 9am and see how the output looks like.
```{r}
destin_cam_ameni <- destin_cam %>%
  filter(amenities == 1)

destin_cam_ameni_sf <- destin_cam_ameni %>%
  st_as_sf(.,coords = c("lat", "lon"), crs = 4326)
```

```{r}
# routing inputs
max_walk_time <- 12 # minutes
max_bike_time <- 12 # minutes
max_trip_duration <- 30 # minutes

# departure datetime
departure_datetime = as.POSIXct("24-04-2023 08:00:00", 
                                format = "%d-%m-%Y %H:%M:%S",
                                tz = "GMT")
```

### testing the method for small area first (Camden)

```{r}
origin_cam_sf$id <- origin_cam_sf$id%>%
  as.character(.)

destin_cam_sf$id <- destin_cam_sf$id%>%
  as.character(.)
```

```{r}
# estimate travel time matrix for walk
ttm_walk <- expanded_travel_time_matrix(r5r_core = r5r_core,   
                          origins = origin_cam_sf,
                          destinations = destin_cam_sf,    
                          mode = c("WALK", "TRANSIT"),
                          max_walk_time = max_walk_time,
                          max_trip_duration = max_trip_duration,
                          departure_datetime = departure_datetime,
                          breakdown = TRUE)

head(ttm_walk, n = 10)
```

```{r}
summary(ttm_walk)
```

For cycle modes, OD pairs with destination as bus stop will be removed.  


```{r}
destin_cam_sf_bike <- destin_cam_sf%>%
  filter(bus_stop == 0)
```
 
 
```{r}
# estimate travel time matrix for bike
ttm_bike <- expanded_travel_time_matrix(r5r_core = r5r_core,   
                          origins = origin_cam_sf,
                          destinations = destin_cam_sf_bike,    
                          mode = c("bicycle","transit"),
                          max_bike_time = max_bike_time,
                          max_trip_duration = max_trip_duration,
                          departure_datetime = departure_datetime,
                          progress = TRUE,
                          time_window = 20,
                          breakdown = TRUE
                          )

head(ttm_bike, n = 10)
```

After getting both travel time, combine the two datasets to get access time. Some OD pairs are reachable only through cycling within 12 min, so cycling time will be preserved in this way and others may be accessible via both modes, although cycling is faster walking will be preserved to cater for the accessibility of wider users.

```{r}
ttm_walk <-ttm_walk %>%
  rename(walk_time = total_time)

ttm_bike <-ttm_bike %>%
  rename(bike_time = total_time)
```

```{r}
ttm_all <- full_join(ttm_walk,ttm_bike,by=c("from_id","to_id"))
```


```{r}
ttm_all <- ttm_all %>%
  mutate (access_time = case_when (!is.na(walk_time) ~ walk_time,
                           !is.na(bike_time) ~ bike_time,
                           TRUE ~ walk_time))
```

```{r}
ttm_all <- ttm_all %>%
  mutate (TAT = case_when (access_time == 0 ~ 0.5,
                           TRUE ~ access_time))
```


```{r}
ttm_all <- ttm_all %>%
  mutate(EDF = 0.5 * (60 / TAT))
```


```{r}
ttm_all_ai <- ttm_all %>%
  group_by(from_id)%>%
  summarize(max=max(EDF),sum=sum(EDF),AI=0.5*max(EDF)+0.5*sum(EDF),count=n())
```


```{r}
origin_cam$id<-as.character(origin_cam$id)
# add coordinates of destinations to travel time matrix

ttm_all_ai<-ttm_all_ai%>%
  merge(origin_cam[,c("id","lon","lat")], by.x = "from_id", by.y = "id")

ttm_all_ai<-ttm_all_ai%>%
  st_as_sf(.,coords = c("lat", "lon"), crs = 4326)

```


```{r}
library(tmap)
tmap_mode("plot")

t_access = 
tm_shape(ttm_all_ai) +
  tm_dots(size = 0.25, col = "AI",palette="YlOrBr") +
tm_shape(destin_cam_sf) +
  tm_dots(col = "blue",alpha=0.5)+
tm_shape(camden) +
  tm_polygons(col = NA, alpha = 0)
  
  
```

```{r}
tmap_save(t_access, 'draft_access_AI.png')
```

### Apply the method to London wise

```{r}
# estimate travel time matrix for walk
ttm_walk_ldn <- travel_time_matrix(r5r_core = r5r_core,   
                          origins = origin_sf,
                          destinations = destin_sf,    
                          mode = 'walk',
                          max_walk_time = max_walk_time,
                          max_trip_duration = max_trip_duration,
                          departure_datetime = departure_datetime,
                          progress = TRUE
                          )

head(ttm_walk_ldn, n = 10)
```

For cycle modes, OD pairs with destination as bus stop will be removed.  


```{r}
destin_sf_bike <- destin_sf%>%
  filter(bus_stop == 0)
```
 
 
```{r}
# estimate travel time matrix for bike
ttm_bike_ldn <- travel_time_matrix(r5r_core = r5r_core,   
                          origins = origin_sf,
                          destinations = destin_sf_bike,    
                          mode = 'bicycle',
                          max_bike_time = max_bike_time,
                          max_trip_duration = max_trip_duration,
                          departure_datetime = departure_datetime,
                          progress = TRUE                          )

head(ttm_bike_ldn, n = 10)
```

After getting both travel time, combine the two datasets to get access time. Some OD pairs are reachable only through cycling within 12 min, so cycling time will be preserved in this way and others may be accessible via both modes, although cycling is faster walking will be preserved to cater for the accessibility of wider users.

```{r}
ttm_walk_ldn <-ttm_walk_ldn %>%
  rename(walk_time = travel_time_p50)

ttm_bike_ldn <-ttm_bike_ldn %>%
  rename(bike_time = travel_time_p50)
```

```{r}
ttm_all_ldn <- full_join(ttm_walk_ldn,ttm_bike_ldn,by=c("from_id","to_id"))
```


```{r}
ttm_all_ldn <- ttm_all_ldn %>%
  mutate (access_time = case_when (!is.na(walk_time) ~ walk_time,
                           !is.na(bike_time) ~ bike_time,
                           TRUE ~ walk_time))
```

```{r}
ttm_all_ldn <- ttm_all_ldn %>%
  mutate (TAT = case_when (access_time == 0 ~ 0.5,
                           TRUE ~ access_time))
```


```{r}
ttm_all_ldn <- ttm_all_ldn %>%
  mutate(EDF = 0.5 * (60 / TAT))
```


```{r}
ttm_all_ldn_ai <- ttm_all_ldn %>%
  group_by(from_id)%>%
  summarize(max=max(EDF),sum=sum(EDF),AI=0.5*max(EDF)+0.5*sum(EDF),count=n())
```


```{r}
origin$id<-as.character(origin$id)
# add coordinates of destinations to travel time matrix

ttm_all_ldn_ai<-ttm_all_ldn_ai%>%
  merge(origin[,c("id","lon","lat")], by.x = "from_id", by.y = "id")

ttm_all_ldn_ai<-ttm_all_ldn_ai%>%
  st_as_sf(.,coords = c("lat", "lon"), crs = 4326)

```


```{r}
library(tmap)
tmap_mode("plot")
tm1 <- tm_shape(ttm_all_ldn_ai) +
  tm_dots(col = "AI",palette="YlOrBr", scale=0.02, alpha = 0.5) +
  tm_shape(London_borough) +
  tm_polygons(col = NA, alpha = 0) +
  tm_credits("(a)", position=c(0,0.85), size=1.5)

tm2 <- tm_shape(destin_sf_ameni) +
  tm_dots(col = "blue",alpha=0.15, scale=0.1) +
  tm_shape(destin_sf_station) +
  tm_dots(col = "red",alpha=0.15, scale=0.1) +
  tm_shape(London_borough) +
  tm_polygons(col = NA, alpha = 0) + 
  tm_credits("(b)", position=c(0,0.85), size=1.5)

t=tmap_arrange(tm1, tm2, ncol=2)

t
```

```{r}
tmap_save(t, 'test.png')
```

Then, for destinations as public transit stations, the total access time includes both the access time above and the waiting time. 



Finally, for cycline mode, destinations with less parking facilities may lead to increased travel time to find and move to the available racks. 

```{r}
r5r::stop_r5(r5r_core)
rJava::.jgc(R.gc = TRUE)
```

